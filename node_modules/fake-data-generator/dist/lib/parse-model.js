'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _faker2 = require('faker');

var _faker3 = _interopRequireDefault(_faker2);

var _helpers = require('./helpers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function configureFaker(config) {
  var _config$locale = config.locale,
      locale = _config$locale === undefined ? 'en' : _config$locale;

  _faker3.default.locale = locale;
}

/**
 * parseModel - Iterates over named keys of an object while recursively parses
 * the given node, until every leaf is parsed.
 * -> An Object model type is considered a Node.
 * -> A model type different than Object is considered a Leaf.
 *
 * @param  {Object} model an object with domain-specific keys
 * @return {Object}
 */
function parseModel(model) {
  if (model.type && typeof model.type === "string") {
    var type = model.type,
        value = model.value,
        options = model.options;

    return modelAttributeTypes[type](value, options);
  }
  var modelKeys = Object.keys(model);
  var parsedModel = modelKeys.reduce(function (accumulator, currentValue) {
    var _model$currentValue = model[currentValue],
        type = _model$currentValue.type,
        value = _model$currentValue.value,
        options = _model$currentValue.options;

    var _value = modelAttributeTypes[type](value, options);

    var _accumulator = Object.assign(accumulator, _defineProperty({}, currentValue, _value));
    return _accumulator;
  }, {});
  return parsedModel;
}

/**
 * parseArray - Given a model and options, iterates 'size' times to generate
 * a list of the parsed 'model' type.
 * -> parseModel can be either a Node or a Leaf.
 *
 * @param  {Object} model   A model Node
 * @param  {Object} options [size: Number]
 * @return {Array} A parsed model
 */
function parseArray(model, options) {
  return [].concat(_toConsumableArray(Array(options.size).keys())).map(function () {
    return parseModel(model.value);
  });
}

/**
 * append - Given a model and options, appends a value to the parsed model.
 * -> parsedModel should return a Leaf.
 * @param  {Object} model A model Node
 * @param  {Object} options [text: Number|String>]
 * @return {String} A parsed model
 */
function append(model, options) {
  return '' + parseModel(model) + options.text;
}

/**
 * prepend - Given a model and options, prepends a value to the parsed model.
 * -> parsedModel should return a Leaf.
 * @param  {Object} model A model Node
 * @param  {Object} options [text: Number|String>]
 * @return {String} A parsed model
 */
function prepend(model, options) {
  return '' + options.text + parseModel(model);
}

var modelAttributeTypes = {
  // Structure types
  Object: parseModel,
  Array: parseArray,
  // Data generators types
  // -- external libs
  faker: function faker(args) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return Object.byString(_faker3.default, args).apply(undefined, _toConsumableArray(options));
  },
  // -- internal libs
  append: append,
  prepend: prepend,
  randomNumberBetween: _helpers.numbers.randomBetween,
  randomNumberBetweenWithString: _helpers.numbers.randomBetweenWithString
};

exports.default = function (modelData) {
  var config = modelData.config,
      model = modelData.model;

  configureFaker(config);

  var parsedModel = parseModel(model);

  return parsedModel;
};